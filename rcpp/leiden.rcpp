#include <Rcpp.h>
#include <vector>
#include <set>
#include <unordered_map>

// define adjacency graph structure with weights 
class Graph {
    // adj is  size n vector of vectors of ints: adj[i] is vector of neighbors of node i 
    // weights is size n vector of vectors of doubles: weights[i] is vector of weights of edges from node i
    // n is number of nodes in graph
public:
    int n; // number of nodes
    std::vector<std::vector<int> > adj; // adjacency list
    std::vector<std::vector<double> > weights; // weights of edges
    
    Graph(int n) : n(n), adj(n), weights(n) {}
    
    void addEdge(int u, int v, double w) {
        adj[u].push_back(v); // add v to u's list of neighbors
        weights[u].push_back(w); // add weight of edge from u to v
    }
};



int countEdges(const Graph& C, const Graph& D) {
    // edge count number;
    int E = 0;
    
    
    std::unordered_map<int, std::set<int>> neighborsC;  // map from node ID to set of neighbors
    std::unordered_map<int, std::vector<double>> weightMapC;  // map from node ID to vector of edge weights
    std::unordered_map<int, std::set<int>> neighborsD;  // map from node ID to set of neighbors

    
    // Populate the maps
    for (int i = 0; i < C.n; i++) { // for each node, i in C
        for (int j = 0; j < C.adj[i].size(); j++) { // for each neighbor, j of node i
            int neighbor = C.adj[i][j];
            double weight = C.weights[i][j];
            neighborsC[i].insert(neighbor);  // add neighbor to set of neighbors
            weightMapC[i].push_back(weight);  // add weight of edge from i to neighbor
        }
    }

    for (int i = 0; i < D.n; i++) {  // for each node, i in D
        for (int j = 0; j < D.adj[i].size(); j++) {  // for each neighbor, j of node i
            int neighbor = D.adj[i][j];  // get neighbor
            neighborsD[i].insert(neighbor);  // add neighbor to set of neighbors
        }
    }

    // Count common neighbors with their weighted edges
    for (int i = 0; i < C.n; i++) {  // for each node, i in C
        for (int neighbor : neighborsC[i]) {  // for each neighbor of node i
            if (neighborsD.find(neighbor) != neighborsD.end()) {  // if neighbor is in D
                for (int k : neighborsD[neighbor]) {  // for each neighbor, k of neighbor
                    if (neighborsC[i].count(k) > 0) {  // if k is also a neighbor of i
                        int index1 = i;
                        int index2 = k;
                        int index3 = neighbor;
                        
                        for (int l = 0; l < C.adj[index1].size(); l++) {  // for each neighbor, l of node i
                            if (C.adj[index1][l] == index3) {  // if l is neighbor of i
                                E += C.weights[index1][l];  
                            }
                        }
                    }
                }
            }
        }
    }

    return E;
}


// calculate constant pots model objective function (H)
double H(Graph G, std::vector<int> P, double gamma) {
    double H = 0;
    // gamma is the resolution parameter
    /* H is sum of weights of edges between nodes in same community minus gamma times the combinatoin of the recursive sum of the combination of the recursive community sizes with subet of 2
    i.e. H(G,P) = sum[ E(C,C) - gamma*nCr(||C||, 2) ] for all communities C in partition P
    and E(C,C) is the number of edges between nodes in community C
    */
    
    // for each community C in partition P
    for (int i = 0; i < P.size(); i++) {
        double E = 0; // number of edges between nodes in community C
        double nCr = 0; // number of combinations of the recursive community sizes with subset of 2
        // count number of edges between nodes in community C
        
        
        
        

// moveNodesFast function

// refinePartition function

// mergeNodesSubset function

// aggregateGraph function

// singletonPartition function






#include <Rcpp.h>
using namespace Rcpp;

typedef List Graph;  // Assuming an adjacency list representation
typedef NumericVector Partition;
typedef std::queue<int> Queue;

double DeltaH(Graph G, Partition P, int node, int community) {
    // To be properly implemented
    // Compute change in modularity when moving 'node' to 'community'
    return 0.0;
}

Partition MoveNodesFast(Graph G, Partition P) {
    Queue Q;
    for (int i = 0; i < G.size(); i++) {
        Q.push(i);
    }

    while (!Q.empty()) {
        int u = Q.front();
        Q.pop();
        
        NumericVector possible_communities = unique(G[u]);
        int bestCommunity = P[u];
        double maxDeltaH = 0;
        for (int i = 0; i < possible_communities.size(); i++) {
            double dh = DeltaH(G, P, u, possible_communities[i]);
            if (dh > maxDeltaH) {
                maxDeltaH = dh;
                bestCommunity = possible_communities[i];
            }
        }
        
        if (bestCommunity != P[u]) {
            P[u] = bestCommunity;
            NumericVector neighbors = G[u];
            for (int i = 0; i < neighbors.size(); i++) {
                Q.push(neighbors[i]);
            }
        }
    }
    return P;
}

Graph AGGREGATEGRAPH(Graph G, Partition P) {
    // Nodes are merged based on partition P
    // For now, returning the same graph
    return G;
}

Partition SINGLETONPARTITION(int n) {
    Partition P(n);
    for (int i = 0; i < n; i++) {
        P[i] = i;
    }
    return P;
}

// Main Leiden function
// [[Rcpp::export]]
Partition LEIDEN(Graph G) {
    Partition P = SINGLETONPARTITION(G.size());
    Partition prevP(G.size(), -1); // Initialize with -1 to ensure they're different

    while (!Rcpp::is_true(Rcpp::all(P == prevP))) { 
        prevP = P;
        P = MoveNodesFast(G, P);
        G = AGGREGATEGRAPH(G, P);
    }
    return P;
}





