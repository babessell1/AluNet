#ifndef GRAPHUTILS_H
#define GRAPHUTILS_H

#include <Rcpp.h>
#include <vector>
#include <set>
#include <random>
#include <unordered_map>

class Graph {
public:
    int n;
    std::map<std::string, int> nodeIndexMap;
    std::unordered_map<int, std::vector<int>> adj;
    std::unordered_map<int, std::vector<double>> edgeWeights;
    std::unordered_map<int, double> nodeWeights;
    std::vector<int> nodes;
    bool isDirected;
    int possibleEdges;
    double totalEdgeWeight;

    Graph(int n);
    void addEdge(const std::string& u, const std::string& v, double w);
    int getNodeIndex(const std::string& node) const;
    std::string getNodeName(int index) const;
    std::vector<int> getNodes() const;
    void removeSingleConnections();
    Rcpp::List graphToRList() const;
    std::vector<int> getNeighbors(int nodeIndex) const;
    double getWeight(int u, int v) const;
    void updateNodeProperties();
};

// listToGraph
Graph listToGraph(const Rcpp::List& graphList);

class RandomGenerator { 
public:
/*    
static std::vector<int> generateRandomPermutation(int n) {
        std::vector<int> permutation(n);
        for (int i = 0; i < n; ++i) {
            permutation[i] = i;
        }
        std::shuffle(permutation.begin(), permutation.end(), std::mt19937(std::random_device()()));
        return permutation;
    }
*/
    static std::vector<int> generateRandomPermutation(int n) {
        std::vector<int> permutation(n);
        for (int i = 0; i < n; ++i) {
            permutation[i] = i;
        }
        // Create a random number generator
        std::random_device rd;
        std::mt19937 g(rd());

        // Use std::shuffle instead of std::random_shuffle
        std::shuffle(permutation.begin(), permutation.end(), g);
        return permutation;
    }
};


#endif
#ifndef COMMUNITY_H
#define COMMUNITY_H

#include <Rcpp.h>
#include "GraphUtils.h"


class Community {
public:
    // properties
    int communityIndex; 
    std::vector<int> nodeIndices;  // node indices
    
    // methods
    Community(const std::vector<int>& nodes, int index); // remember to convert input to vector in a vector when constructing!!
    double aggregateWeights(const Graph& G); // sum weights of all edges in the community and count number of nodes
    size_t size(); // number of nodes in the community
    int countPossibleEdges(const Graph& G); // count possible edges in the community
    double getClusterWeight(const Graph&G) const; // sum weights of all nodes in the community

};

#endif

#include <Rcpp.h>
#include "GraphUtils.h"
#include "Community.h"

/*
################################################################################
############################ COMMUNITY CLASS ###################################
*/
// Construct a community base on a set of node indices, and a community index
Community::Community(const std::vector<int>& nodes, int index)
    : communityIndex(index), nodeIndices(nodes) {
}

// get the sum of weights of all edges in the community
double Community::aggregateWeights(const Graph& G) {
    double weight_sum = 0.0;
    for (int& node_index : nodeIndices) {
        // get the neighbors of the node
        std::vector<int> neighbors = G.getNeighbors(node_index);
        // for each neighbor of the node
        for (int& neighbor_index : neighbors) {
            // if the neighbor is in the community, add the weight of the edge to the sum
            weight_sum += G.getWeight(node_index, neighbor_index);
        }
    }
    return weight_sum;
}

int Community::countPossibleEdges(const Graph& G) {
    // get the number of possible edges in the community, assuming undirected graph
    // do not count zero weight edges
    int n_possible_edges = 0;
    for (int& node_index : nodeIndices) {
        // get the neighbors of the node
        std::vector<int> neighbors = G.getNeighbors(node_index);
        // count possible edges
        for (int& neighbor_index : neighbors) {
            // if the neighbor is in the community, add the weight of the edge to the sum
            if (G.getWeight(node_index, neighbor_index) > 0.0) {
                n_possible_edges++;
            }
        }
    }
    return n_possible_edges;
}


// get the number of nodes in the community
size_t Community::size() {
    return nodeIndices.size();
}

double Community::getClusterWeight(const Graph& G) const {
    // get the sum of weights of all nodes in the community
    double weight_sum = 0.0;
    for (int node_index : nodeIndices) {
        double weight_add = G.nodeWeights.at(node_index);  // Using 'at' for bounds checking
        weight_sum += weight_add;
    }
    return weight_sum;
}
#ifndef PARTITION_H
#define PARTITION_H

#include <Rcpp.h>
#include "GraphUtils.h"

class Partition {
public:
    // properties
    std::unordered_map<int, Community> communityIndexMap;
    std::unordered_map<int, int> nodeCommunityMap;
    double quality;

    // methods
    Partition(const std::vector<Community>& communities);
    std::vector<int> getCommunityIndices() const;
    void flattenPartition();
    void updateCommunityMembershipSearch(int node_index, int new_community_index);
    void updateCommunityMembership(int node_index, int old_community_index, int new_community_index);
    int getNodeCommunity(int node_index);
    void purgeEmptyCommunities(bool leave_one);
    void addCommunity(const Community& newCommunity);
    std::vector<double> getPartitionWeights(const Graph& G) const;
    double calcQuality(double gamma, const Graph& G) const;
};

#endif
#include <Rcpp.h>
#include "GraphUtils.h"
#include "Community.h"
#include "Partition.h"

/*
################################################################################
############################ PARTITION CLASS ###################################
*/
// Construct a partition based on a set of communities
Partition::Partition(const std::vector<Community>& communities) {
    for (const auto& community : communities) {
        // add the community to the community map
        communityIndexMap.insert({community.communityIndex, community});
        // for each node in the community
        for (int node_index : community.nodeIndices) {
            // add the node to the node map
            nodeCommunityMap.insert({node_index, community.communityIndex});
        }
    }
    // initialize the quality
    quality = 0.0;
}
    
// get indices of communities in the partition (different from node indices!)
std::vector<int> Partition::getCommunityIndices() const {
    // get community indices
    // from communityIndexMap
    std::vector<int> indices;
    for (const auto& entry : communityIndexMap) {
        indices.push_back(entry.first);
    }

    return indices;
}

// flatten the partition, last step of the optimization step in the paper
 void Partition::flattenPartition() {
    // for each community index in the partition
    for (int communityIndex : getCommunityIndices()) {
        // get the community
        auto comm = communityIndexMap.find(communityIndex);
        // flatten the subsets
        std::vector<int> flat_set;
        for (int nidx : comm->second.nodeIndices) {
            flat_set.push_back(nidx);
        }
        // set the flat set as the community in the map
        // store as a vector of vectors!
        comm->second.nodeIndices = flat_set;
    }
}

void Partition::addCommunity(const Community& newCommunity) {
    // Add the new community to the communities vector
    communityIndexMap.insert({newCommunity.communityIndex, newCommunity});
}

// Function to get the community of a given vertex
int Partition::getNodeCommunity(int n_idx) {
    // get the community of the node
    auto node_it = nodeCommunityMap.find(n_idx);
    if (node_it != nodeCommunityMap.end()) {
        return node_it->second;
    } else {
        Rcpp::stop("Node not found in the node community map: " + std::to_string(n_idx));
    }
  }

std::vector<double> Partition::getPartitionWeights(const Graph& G) const {
    // for each cluster, get the sum of weights of all nodes in the community
    std::vector<double> cluster_weights;
    for (int c_idx : getCommunityIndices()) {
        cluster_weights.push_back(communityIndexMap.at(c_idx).getClusterWeight(G));
    }
    return cluster_weights;
}

// move a node from one community to another
void Partition::updateCommunityMembershipSearch(int node_index, int new_community_index) {
    // Find the current community of the node and remove the node from the community
    bool found = false;
    for (auto& entry : communityIndexMap) {
        // if the node is in the community, (throw error if not found)
        auto node_it = std::find(entry.second.nodeIndices.begin(), entry.second.nodeIndices.end(), node_index);
        if (node_it != entry.second.nodeIndices.end()) {
            // remove the node from the community
            entry.second.nodeIndices.erase(node_it);
            found = true;
        }
    }
    if (!found) {
        Rcpp::stop("Node not found in any community: " + std::to_string(node_index));
    }

    // Add the node to the new community
    communityIndexMap.at(new_community_index).nodeIndices.push_back(node_index);
}

void Partition::updateCommunityMembership(int node_index, int old_community_index, int new_community_index) {
    // Find the current community of the node and remove the node from the community
    auto old_comm = communityIndexMap.find(old_community_index);
    if (old_comm != communityIndexMap.end()) {
        // if the node is in the community, remove it
        auto node_it = std::find(old_comm->second.nodeIndices.begin(), old_comm->second.nodeIndices.end(), node_index);
        if (node_it != old_comm->second.nodeIndices.end()) {
            old_comm->second.nodeIndices.erase(node_it);
        } else {
            Rcpp::stop("Node not found in the old community: " + std::to_string(node_index));
        }
    } else {
        Rcpp::stop("Old community not found: " + std::to_string(old_community_index));
    }

    // Add the node to the new community
    communityIndexMap.at(new_community_index).nodeIndices.push_back(node_index);
}

// ################################
// [[test it]]

// purge empty communities
void Partition::purgeEmptyCommunities(bool leave_one) {
    // Remove empty communities
    for (auto it = communityIndexMap.begin(); it != communityIndexMap.end();) {
        if (it->second.size() == 0) {
            it = communityIndexMap.erase(it);
        } else {
            ++it;
        }
    }
    // if leave_one, create one empty community as an option to move nodes to
    if (leave_one) {
        // get the index of the last community
        int last_index = communityIndexMap.begin()->first;
        // create an empty community
        Community empty_community({}, last_index + 1);
        // add the empty community to the partition
        communityIndexMap.insert({last_index + 1, empty_community});
    }

    // renumber the communities to be consecutive
    int new_index = 0;
    for (auto& entry : communityIndexMap) {
        entry.second.communityIndex = new_index;
        // find index of the community to be updated in the nodeCommunityMap and update it
        auto node_it = nodeCommunityMap.find(entry.first);
        if (node_it != nodeCommunityMap.end()) {
            node_it->second = new_index;
        } else {
            Rcpp::stop("Node not found in the node community map: " + std::to_string(entry.first));
        }
        new_index++;
    }
}

double Partition::calcQuality(double gamma, const Graph& G) const {
   /*
    Calculate the quality of the partition 1 / (2 * m) * sum(d(c[i], c[j]) * (a[i][j] - gamma * n[i] * n[j])),
    where:
        a[i][j] is the weight of the edge between nodes i and j
        d(c[i], c[j]) is 1 if c[i] == c[j] and 0 otherwise
        gamma is the resolution parameter
        n[i] is the weight of node i
        m is the total edge weight
        sum is over all pairs of nodes i and j in the graph
    */

    double quality = 0.0;
    // for each node in the graph
    for (int node_idx : G.nodes) {

        // print
        Rcpp::Rcout << "neighbors of node " << node_idx << std::endl;
        // print G.getNeighbors(node_idx);
        for (int neigh_idx : G.getNeighbors(node_idx)) {
            Rcpp::Rcout << neigh_idx << std::endl;
        }



        // get the neighbors of the node
        for (int neigh_idx : G.getNeighbors(node_idx)) {
            // get the weight of the edge between the node and its neighbor

            //print G.edgeWeights.at(node_idx).at(neigh_idx);
            Rcpp::Rcout << "edge weight: " <<  std::endl;
            for (int i = 0; i < G.edgeWeights.at(node_idx).size(); i++) {
                Rcpp::Rcout << G.edgeWeights.at(node_idx).at(i) << std::endl;
            }

            double edge_weight = G.edgeWeights.at(node_idx).at(neigh_idx);
            // if the neighbor is in the same community as the node

            // print community map
            Rcpp::Rcout << "community map: " << std::endl;
            for (auto& entry : nodeCommunityMap) {
                Rcpp::Rcout << entry.first << " " << entry.second << std::endl;
            }

            if (nodeCommunityMap.at(node_idx) == nodeCommunityMap.at(neigh_idx)) {
                // add the edge weight to the quality
                quality += edge_weight;
            }
        }
    }
    // our graph has no self links, so we do not need to handle them for now
    std::vector<double> p_weights = getPartitionWeights(G);
    // for each community in the partition, get the weight of the community and remove it from the quality
    for (int c_idx : getCommunityIndices()) {
        // get the weight of the community
        double c_weight = p_weights.at(c_idx);
        // subtract the weight of the community from the quality
        quality -= gamma * c_weight * c_weight;
    }

    quality /= 2 * G.totalEdgeWeight;

    return quality;   
}
#ifndef LEIDEN_H
#define LEIDEN_H

#include "GraphUtils.h"

class Optimizer {
public:
    // properties
    Graph& G;
    Partition& P;
    double gamma;

    // methods
    Optimizer(Graph& G, Partition& P, double gamma);
    void optimize();
    bool moveNodesFast();
    //Partition refinePartition() const;
    //Partition mergeNodesSubset(const Community& subset);
    //Graph aggregateGraph(const Graph& G, const Partition& P);
    double calcQuality(double gamma);
    double deltaQuality(int n_idx, int new_c_idx, double gamma) const;
};

Partition initializePartition();

#endif
#include <Rcpp.h>
#include "GraphUtils.h"
#include "Community.h"
#include "Partition.h"
#include "Leiden.h"

#include <queue>


// [[test it]

// not finished, should define an extra function named quality()
// which counts the weights
// [[test it]]

/*
size_t Partition::number_of_nodes() {
    // Implement the logic to return the number of nodes in the partition
    return graph.n; // Assuming n is the number of nodes in the graph
}

Graph Partition::get_graph() {
    // Implement the logic to return the graph object associated with the partition
    return graph;
}

void Partition::addCommunity(const Community& newCommunity) {
    // Implement logic to add a new community to the partition
    communities.push_back(newCommunity);
}

void Partition::removeCommunity(int communityIndex) {
    // Implement logic to remove a community from the partition
    // You may want to handle the case where the index is out of bounds
}

void Partition::updateCommunityMembership(int node_index, int new_community_index) {
    // Implement logic to update the community membership of a node
    // You may want to handle the case where the indices are out of bounds
}

*/
/*
################################################################################
############################ OPTIMIZER CLASS ###################################
*/
// Construct an optimizer based on a graph and a partition
Optimizer::Optimizer(Graph& G, Partition& P, double gamma) : G(G), P(P), gamma(gamma) {}

double Optimizer::deltaQuality(int n_idx, int new_c_idx, double gamma) const {
  // calculate the difference between moving vertex to a new community

    // print getting old community
    Rcpp::Rcout << "Getting old community" << std::endl;

    // print node index
    Rcpp::Rcout << "Node index: " << n_idx << std::endl;

    int old_c_idx = P.nodeCommunityMap.at(n_idx);  // keep track of the old community

    // print old community
    Rcpp::Rcout << "Old community: " << old_c_idx << std::endl;

    // get quality of the partition before the move
    double old_quality = P.calcQuality(gamma, G);

    // make copy of the partition
    Partition P_new = P;

    // print updating temporary partition
    Rcpp::Rcout << "Updating temporary partition" << std::endl;

    // move the node to the new community
    P_new.updateCommunityMembership(n_idx, old_c_idx, new_c_idx);
    // purge empty communities

    // print purging empty communities
    Rcpp::Rcout << "Purging empty communities in temp" << std::endl;
    P_new.purgeEmptyCommunities(false);

    // get quality of the partition after the move
    double new_quality = P_new.calcQuality(gamma, G);

    // return the difference in quality
    return new_quality - old_quality;

}

// Leiden fast local move iteration
bool Optimizer::moveNodesFast() {
    bool update = false;  // track if the partition has changed

    std::vector<bool> stable_nodes(G.n, false); // track which nodes have not moved
    std::vector<double> cluster_weights(G.n, 0.0);
    std::vector<double> edge_weights_per_cluster(G.n, 0.0);  // track the sum of edge weights per cluster
    std::vector<int> nodes_per_cluster(G.n, 0);  // track the number of nodes in each cluster (more efficient than calling size() on each cluster)
    std::vector<int> unused_clusters(G.n-1, 0);  // track which clusters are empty
    std::vector<int> n_neighboring_clusters(G.n, 0);  // track the number of neighboring clusters for each cluster

    // print starting message
    Rcpp::Rcout << "Starting move iteration" << std::endl;

    int n_unused_clusters = 0;
    int n_unstable_nodes = G.n;

    std::queue<int> node_queue;
    std::vector<int> random_nodes = RandomGenerator::generateRandomPermutation(G.n);

    // print length of queue
    Rcpp::Rcout << "Length of queue: " << random_nodes.size() << std::endl;

    for (int node_index : random_nodes) {
        node_queue.push(node_index);
    }

    // print "pushed"
    Rcpp::Rcout << "Pushed" << std::endl;

    // initialize the cluster weights and nodes per cluster
    for (const auto& entry : G.nodeIndexMap) {
        int node_index = entry.second;
        cluster_weights[node_index] = G.nodeWeights[node_index];
        nodes_per_cluster[node_index]++;
    
    }

    // print "initialized cluster weights and nodes per cluster"
    Rcpp::Rcout << "Initialized cluster weights and nodes per cluster" << std::endl;


    // get the node indices in the graph
    std::vector<int> node_indices;
    for (auto entry : G.nodeIndexMap) {
        node_indices.push_back(entry.second);
    }

    // print "got node indices"
    Rcpp::Rcout << "Got node indices" << std::endl;
    
    // for each node in the network (go backwards)
    std::vector<int> rev_node_indices;
    for (int i = G.n - 1; i >= 0; i--) {
        rev_node_indices.push_back(node_indices[i]);
    }

    // print "reversed node indices"
    Rcpp::Rcout << "Reversed node indices" << std::endl;

    for (int nidx : rev_node_indices) {
        // print nodes per cluster
        //Rcpp::Rcout << nodes_per_cluster[nidx] << std::endl;
        // if no nodes in cluser
        if (nodes_per_cluster[nidx] == 0) {
            // add to unused clusters
            unused_clusters[n_unused_clusters] = nidx;
            n_unused_clusters++;
        }
    }

    // print "added unused clusters"
    Rcpp::Rcout << "Added unused clusters" << std::endl;
    // print them all
    Rcpp::Rcout << "Unused clusters: " << std::endl;
    for (int i = 0; i < n_unused_clusters; i++) {
        Rcpp::Rcout << unused_clusters[i] << std::endl;
    }

    /*
    * Iterate over the nodeOrder array in a cyclical manner. When the end
    * of the array has been reached, start again from the beginning. The
    * queue of nodes that still need to be visited is given by
    * nodeOrder[i], ..., nodeOrder[i + nUnstableNodes - 1]. Continue
    * iterating until the queue is empty.
    */
    do {
        // print start while loop
        Rcpp::Rcout << "Start while loop" << std::endl;
        int j = node_queue.front();
        node_queue.pop();
        // if the node is stable, skip it
        // get current community of node j
        int c_idx = P.nodeCommunityMap.at(j);

        /*
        * Identify the neighboring clusters of the currently selected
        * node, that is, the clusters with which the currently selected
        * node is connected. An empty cluster is also included in the set
        * of neighboring clusters. In this way, it is always possible that
        * the currently selected node will be moved to an empty cluster.
        */

       // print "get neighborhood
         Rcpp::Rcout << "Get neighborhood" << std::endl;

        // get the neighbors of node j
        std::vector<int> neighbors = G.getNeighbors(j);
        int n_neighboring_clusters = 1;  // track the number of neighboring clusters
        // get the neighboring clusters of node j
        std::set<int> neighboring_clusters;
        // add empty cluster to neighboring clusters
        neighboring_clusters.insert(unused_clusters[n_unused_clusters-1]);
        for (int nn_idx : neighbors) {  // neighbors of node j
            // get the community of the neighbor
            int nc_idx = P.nodeCommunityMap.at(nn_idx);  // nieghbor community index
            // if edge weight of cluster is 0
            if (edge_weights_per_cluster[nc_idx] == 0) {
                // add to neighboring clusters
                neighboring_clusters.insert(nc_idx);
                n_neighboring_clusters++;
            }
            edge_weights_per_cluster[nc_idx] += P.communityIndexMap.at(nc_idx).getClusterWeight(G);
        }

        // print "ensuring empty cluster is in neighboring clusters"
        Rcpp::Rcout << "Ensuring empty cluster is in neighboring clusters" << std::endl;

        // find an empty cluster, first check if only self is in the current cluster
        // if true, then the current cluster is empty
        if (P.communityIndexMap.at(c_idx).size() == 1) {
            // add the current cluster to the neighboring clusters
            neighboring_clusters.insert(c_idx);
        } else {
            // get first empty cluster
            int empty_cluster = unused_clusters[0];
            // add the empty cluster to the neighboring clusters
            neighboring_clusters.insert(empty_cluster);
        }

        /*
        * For each neighboring cluster of the currently selected node,
        * calculate the increment of the quality function obtained by
        * moving the currently selected node to the neighboring cluster.
        * Determine the neighboring cluster for which the increment of the
        * quality function is largest. The currently selected node will be
        * moved to this optimal cluster. In order to guarantee convergence
        * of the algorithm, if the old cluster of the currently selected
        * node is optimal but there are also other optimal clusters, the
        * currently selected node will be moved back to its old cluster.
        */

        // print "finding best cluster"
        Rcpp::Rcout << "Finding best cluster" << std::endl;

        // initialize the best cluster and the best quality
        int best_cluster = c_idx;
        double best_quality_increment = 0.0;
        // for each neighboring cluster
        for (int nc_idx : neighboring_clusters) {
            // calculate the quality of the move
            double delta_q = deltaQuality(j, nc_idx, gamma);
            // if the quality of the move is better than the best quality
            if (delta_q > best_quality_increment) {
                // update the best quality and best cluster
                best_quality_increment = delta_q;
                best_cluster = nc_idx;
            }
        }
        // print cluster
        Rcpp::Rcout << "Cluster was : " << c_idx << std::endl;
        // print best cluster is: cluster
        Rcpp::Rcout << "New best cluster is: " << best_cluster << std::endl;

        // mark the node as stable, remove it from the queue
        stable_nodes[j] = true;
        n_unstable_nodes--;

        /* if the new cluster of the currently selected node is different
        from the old cluster, some further updating of statistics is 
        performed. Also, neighbors of the currently selected node that do
        not belong to the new cluster are marked as unstable and added to
        the queue. 
        */
       if (best_cluster != c_idx) {
            // update cluster stats
            P.updateCommunityMembership(j, c_idx, best_cluster);
            cluster_weights[best_cluster] += G.nodeWeights[j];
            nodes_per_cluster[best_cluster]++;
            if (best_cluster == unused_clusters[n_unused_clusters-1]) {
                n_unused_clusters--;
            }

            P.nodeCommunityMap.at(j) = best_cluster;
            // do some extra managment if best cluster is the empty cluster?
            // get the neighbors of node j
            std::vector<int> neighbors = G.getNeighbors(j);
            // get the neighboring clusters of node j
            std::set<int> neighboring_clusters;
            for (int nn_idx : neighbors) {
                // get community of neighbor
                int nc_idx = P.nodeCommunityMap.at(nn_idx);
                // if the neighbor is stable and neighbor's cluster is not the best cluster
                if (nc_idx != best_cluster && stable_nodes[nc_idx] == true) {
                    stable_nodes[nc_idx] == false;
                    n_unstable_nodes++;
                    // add to node queue with this java logic
                    // add to the end of the queue
                    node_queue.push(nn_idx);
                }
            }
            update = true;
       }
       // get next node in the queue
    } while (n_unstable_nodes > 0);

    if (update) {
        // purge empty clusters
        P.purgeEmptyCommunities(false);

    }
    return update;
}

/*
Partition Optimizer::moveNodesFast() {
    // Implement the Leiden move operation
    Partition updatedPartition; // Placeholder, replace with actual logic
    return updatedPartition;
}

Partition Optimizer::refinePartition() {
    // Implement creating a new partition from the existing partition
    Partition refinedPartition; // Placeholder, replace with actual logic
    return refinedPartition;
}

Partition Optimizer::mergeNodesSubset(const Community& subset) {
    // Implement refining a community
    Partition mergedPartition; // Placeholder, replace with actual logic
    return mergedPartition;
}

// this is the main idea and the functions shuold be defined.
Graph Optimizer::aggregateGraph(const Graph& G, const Partition& P) {
    size_t numCommunities = P.numberOfCommunities();
    Graph aggregatedGraph(numCommunities); 

    // Iterate through each edge in the original graph
    for (const auto& edge : G.getEdges()) { // Assuming getEdges() returns all edges in the graph
        int u = edge.first;
        int v = edge.second;
        
        int communityU = P.getCommunityOfNode(u); // Assuming getCommunityOfNode() gets the community of a node
        int communityV = P.getCommunityOfNode(v);

        // Add an edge between the communities in the aggregated graph
        // This will handle multi-edges automatically if the same edge is added multiple times
        // note that our addEdge function is string and should plug in the weight
        // so the function should be revised
        // aggregatedGraph.addEdge(communityU, communityV);
    }

    return aggregatedGraph;
}

*/
void Optimizer::optimize() {
    // Implement the Leiden algorithm iteration here
    // This involve multiple steps, such as moveNodesFast, refinePartition, mergeNodesSubset, etc.
    bool done = false;
    while (!done) {
        moveNodesFast();
        //Partition P_refined = refinePartition();
        //aggregateGraph(P_refined);

        // set true no matter what for now
        done = true;
    }
    // test 
    P.flattenPartition();
}

Partition initializePartition(const Graph& G) {
    std::vector<Community> communities;

    // Assign each node to its own community
    // for each node in the getNodes
    int community_index = 0;
    for (int node_index : G.nodes) {
        // Construct a community with a single node
        Community community({node_index}, community_index);
        communities.push_back(community);
        community_index++;
    }

    Partition P(communities);

    return P;
}

// [[Rcpp::export]]
Rcpp::List runLeiden(Rcpp::List graphList, int iterations) {

    // Set the resolution parameter
    double gamma = 1.0;

    // Create a graph from the R List
    // use listToGraph from GraphUtils.cpp
    Graph G = listToGraph(graphList);
    // print the number of nodes 
    Rcpp::Rcout << "Number of nodes: " << G.n << std::endl;
    Partition P = initializePartition(G);
    // print the number of communities
    Rcpp::Rcout << "Number of communities: " << P.communityIndexMap.size() << std::endl;

    // Create an Optimizer
    Optimizer optim(G, P, gamma);

    // Run the Leiden algorithm for the specified number of iterations
    for (int i = 0; i < iterations; i++) {
        // Run the Leiden algorithm
        optim.optimize();
    }

    /* OLD TESTING CODE
    move node 168 to community 126
    optim.P.updateCommunityMembership(168, 168, 126);

    // print nodes in community 126
    Rcpp::Rcout << "Nodes in community 126: " << std::endl;
    for (int node_index : optim.P.communityIndexMap.at(126).nodeIndices) {
        Rcpp::Rcout << node_index << std::endl;
    }
    // print nodes in community 168
    Rcpp::Rcout << "Nodes in community 168: " << std::endl;
    for (int node_index : optim.P.communityIndexMap.at(168).nodeIndices) {
        Rcpp::Rcout << node_index << std::endl;
    }

    // purge empty communities
    optim.P.purgeEmptyCommunities(false);

    */

    // get the communities from the partition
    std::vector<int> communities;
    std::vector<int> nodes;
    for (const auto& entry : optim.P.communityIndexMap) {
        communities.push_back(entry.first);
        for (int node_index : entry.second.nodeIndices) {
            nodes.push_back(node_index);
        }
    }

    // Convert the vector of communities to an R List
    Rcpp::List result = Rcpp::List::create(
        Rcpp::Named("communities") = communities,
        Rcpp::Named("nodes") = nodes
    );

    return result;

}
